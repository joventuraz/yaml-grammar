#!/usr/bin/env perl

# Add explanation/rules section to the top of the grammar
#
# Preserve custome comments
#   Save in spec-1.2-comments.yaml
#
# Also publish as JSON (spec-1.2.json).
#
# - s-space{m} becomes
#   - s-space*
# and
# - <where_m_<_n> becomes
#   - [ (lt), $lastMatchLength, n ]
#
# s-indent(<n) becomes
#   s-indent-lt(n)
#
# s-indent(<=n) becomes
#   s-indent-le(n)
#
# followed_by_an_ns-plain-safe(c) becomes
#   ns-plain-safe(c)=
#
# not_followed_by_an_ns-char becomes
#   ns-char!
#
# [ c, =, "flow-out", =>, nb-single-multi-line(n) ] becomes
# (case):
#   var: c
#   "flow-out": nb-single-multi-line(c)
#
# [ c, =, "flow-out", =>, "flow-in" ] becomes
# (switch):
#   var: c
#   "flow-out": "flow-in"
#
# [ ns-dec-digit, =>, m, ns-dec-digit, -, x30 ] becomes
#   - ns-dec-digit
#   - [ (set), $m, [ (charToInt), $lastMatchValue ] ]
#
# [ - =>, t, =, strip ] becomes
#   - '-'
#   - [ (set), $t, "strip" ]
#
# [ c, =, "block-out", =>, n-1 ] becomes
#   (switch):
#     var: c
#     "block-out": [ (minusOne), n ]
#
# ns-flow-yaml-node(n/a,c) becomes
#   ns-flow-yaml-node(null,c) or
#   ns-flow-yaml-node(0,c) or
#   ns-flow-yaml-node(-1,c)
#
# Weird rules: 163, 170, 183
# What is:
# - <for_some_fixed_auto-detected_m_>_0>

use strict;
use warnings;
use YAML::PP;
my $ypp = YAML::PP->new();

use XXX;

my $debug = 0;

sub main {
  my $index = 0;
  for (@_) {
    if ($_ eq '--index') {
      $index = 1;
    }
    if (/^--debug=(\d+)$/) {
      $debug = $1;
    }
  }
  my $text = do { local $/; <STDIN> };
  $text = reformat($text);
  if ($index) {
    $text = make_index($text);
  }
  else {
    $text = make_yaml($text);
  }
  print "### Generated from https://yaml.org/spec/1.2/spec.html\n\n";
  print $text;
  print "\n# vim: iskeyword=@,+,- sw=2:\n";
}

sub reformat {
  $_ = shift;

  # Get section containing all productions:
  s/.*
    (
      ^5\.1\.\ Character\ Set
      .*
    )
    ^\ \ \ Example\ 9\.6\.\ Stream
    .*
  /$1/smx;

  # Remove reference numbers ([123] and [1234]):
  s/\[\d{3,4}\](?!\s)//g;

  # Collapse broken comments:
  s/(\/\*[^*]+)\n/$1/g;
  s/(\/\*[^*]+)\n/$1/g;

  # Blank out text lines following a rule:
  s/^   [A-Z].*//gm;
  s/^    ? ?\* [A-Z].*//gm;

  # Remove all leading whitespace:
  s/^\ +//gm;

  # Add extra blank lines between paragraphs:
  s/^\[/\n\n[/gm;
  s/\n\n/\n\n\n/gm;

  # Remove all extra prose paragraphs:
  s/\n\n(?!\n|\[\d|\d+\.\d+\.(?:\d+\.)?\ ).*?(?=\n\n)/\n\n/gs;

  # Remove extra blank lines:
  s/\n\n+/\n\n/g;

  # Remove comments
  s/
    \ *\/\*\ +
    (?:
      (?:A|a|0|8|16|32|LF|CR|SP|TAB|DOS|MacOS|UNIX|Key|Value)
      [\-\ \,]
      .*?
    )
    \ *\*\/
  //gx;

  # Fix typo in spec:
  s/safe\(c\)\)/safe(c)/g;

  # Various normalizations:
  s/::= ([ct]) = /::=\n$1 = /g;
  s/⇒/=>/g;
  s/=>\n/=> /g;
  s/::= +/::=\n/g;
  s/ \|\n/ \| /g;
  s/ -\n/ - /g;
  s/  +/ /g;
  # s/“'”/"'"/g;
  s/“(.)”/'$1'/g;
  s/#x/x:/g;
  s/≤/<=/g;
  s/ =\n/ = /g;
  s/\)\)/) )/g;
  s/ × (\S+)/{$1}/g;

  # Make special comments into tokens:
  sub token {
    $_ = lc $_[0];
    s/\) \)/))/g;
    s/ /_/g;
    $_;
  }
  s/\/\*\ (.*?)\ \*\//'<' . token($1) . '>'/ge;

  # Parenthesize => expressions:
  s/^(.* = .*)/( $1 )/gm;

  # Remove unwanted space in a couple rules:
  s/(ns-s-flow-seq-entries\(n,in-flow\(c\)) (\)\?)/$1$2/;
  s/(ns-s-flow-map-entries\(n,in-flow\(c\)) (\)\?)/$1$2/;
  s/(l\+block-sequence\(seq-spaces\(n,c\)) (\))/$1$2/;

  # Add missing parens in rule 211:
  s/(l-document-suffix\+ l-document-prefix\*\nl-any-document\?)(\n\| )(l-document-prefix\* l-explicit-document\?)/( $1 )$2( $3 )/;


  return $_;
}

my ($tokens, $seqs, $num, $key);
sub make_index {
  my $text = shift;
  my $index = '';

  while ($text =~ s/.*?\n\[(\d+)\]\ (\S+)//s) {
    $index .= "'$1': $2\n";
  }

  return $index;
}

sub make_yaml {
  my $text = shift;

  my @yaml = ();

  while ($text =~ s/^(\S.*?)\n\n+//s) {
    my $para = $1;
    if ($para =~ /^\d/) {
      push @yaml, make_comment($para);
    }
    elsif ($debug && $para =~ /(\d+)/) {
      next unless $debug == $1;
      warn make_rule($para);
      exit;
    }
    else {
      push @yaml, make_rule($para);
    }
  }

  my $yaml = join "\n\n", @yaml;

  return $yaml;
}

sub make_comment {
  $_ = shift;

  my $comment;

  if (/^\d+\.\d+\.\d+\./) {
    return "##### $_";
  }
  else {
    return "### $_";
  }
}

sub make_rule {
  my $text = shift;
  my $orig = $text;

  $orig =~ s/^/  /gm;
  $orig =~ s/^  //;
  $orig =~ s/ /\n/;
  $orig =~ s/^/# /gm;
  $orig =~ s/.*\n//;

  $text =~ s/^\[(\d+)\]\ (\S+)\ ::=\n// or die $text;
  ($num, $key) = ($1, $2);

  make_tokens($text);

  my $rule;
  if (
    $text =~ s{\( t = (\S+) => (\S+) \| (<end_of_file>) \)}
             {- [ t, =, $1, =>, [ '(|)', $2, $3 ] ]}g
  ) {
    $rule = "\n$text\n";
  }
  elsif (ref($tokens->[0]) and (grep $_ eq '=>', @{$tokens->[0]})) {
    $rule = special_format_1($tokens);
  }
  elsif (@$tokens == 1 and not ref $tokens->[0]) {
    $rule = $ypp->dump($tokens->[0]);
    $rule =~ s/^--- //;
  }
  else {
    $rule = $ypp->dump($tokens);
    $rule =~ s/^---//;
  }

  $rule =~ s/- ([\w<.=+;()\/\$\\])$/- '$1'/gm;
  $rule =~ s/^(.)$/'$1'/gm;
  $rule =~ s/((?:block|flow)-(?:in|out|key)(?=[,\)]|\ \]))/"$1"/g;

  # XXX Can go away after YAML::PP@0.024
  $rule =~ s/''''$/"'"/gm;

  my $yaml = "$orig\n$key: $rule";
  $yaml =~ s/\ +$//gm;
  $yaml = sprintf qq{"%03d": "%s"\n"#%s": "%03d"\n%s},
    $num, $key, $key, $num, $yaml;

  return $yaml;
}

sub special_format_1 {
  my ($tokens) = @_;
  my $out = "\n";
  for my $array (@$tokens) {
    $array = [ map { /,/ ? "'$_'" : $_ } @$array ];
    $out .= '- [ ' . join(', ', @$array) . " ]\n";
  }
  return $out;
}

sub make_tokens {
  my $text = shift;
  $tokens = [];
  my $insert = [$tokens];
  my @input = split /\s+/, $text;

  if (@input > 1 and $input[0] =~ /^'([?*|])'$/) {
    $input[0] = "$1";
  }

  for (my $i = 0; $i < @input; $i++) {
    my $token = $input[$i];

    if ($token eq '|' and
        @{$insert->[-1]} > 1 and
        not grep $_ eq '|', @{$insert->[-1]}
    ) {
      my $array = $insert->[-1];
      @$array = ([@$array], '|');
      next;
    }
    if ($token eq '(') {
      my $array = [];

      push @{$insert->[-1]}, $array;
      push @$insert, $array;
      next;
    }
    elsif ($token =~ /^\)([\*\+\?]?)/) {
      my $q = $1 || '';
      my $array = pop @$insert;
      if (@$array > 1 and $array->[1] =~ /^[-|]$/) {
        my $operator = $array->[1];
        @$array = grep { $_ ne $operator } @$array;
        unshift @$array, "($operator)";
        if ($q) {
          my @array;
          while (@$array) {
            push @array, shift(@$array);
          }
          push @$array, "($q)", \@array;
        }
      }
      elsif ($q) {
        unshift @$array, "($q)";
      }
      next;
    }
    push @{$insert->[-1]}, format_token($token);
  }
  if (@$tokens > 1 and $tokens->[1] =~ /^[-|]$/ and $tokens->[0] ne $tokens->[1]) {
    my $operator = $tokens->[1];
    my $i = 0;
    @$tokens = grep { ++$i % 2 } @$tokens;
    unshift @$tokens, "($operator)";
  }

  for (my $i = 0; $i < @$tokens; $i++) {
    my $token = $tokens->[$i];
    if (ref($token) eq 'ARRAY' and @$token == 1) {
      $tokens->[$i] = $token->[0];
    }
  }

  if (
    ref($tokens) eq 'ARRAY' and
    @$tokens == 1 and
    ref($tokens->[0]) eq 'ARRAY'
  ) {
    $tokens = $tokens->[0];
  }

  # warn $ypp->dump(["($num) $key", $text, $tokens]) if $num >= 1;
}

sub format_token {
  $_ = shift;

  if (/^x:(.*)/) {
    $_ = format_hex($1);
  }
  elsif (/^\[x:(.*)-x:(.*)\]$/) {
    $_ = format_hex($1) . '-' . format_hex($2);
  }
  elsif (/^'(.*)'/) {
    $_ = $1;
  }

  $_;
}

sub format_hex {
  $_ = shift;
  if (length("$_") % 2) {
    $_ = "0$_"
  }
  return "x$_";
}

main @ARGV;
