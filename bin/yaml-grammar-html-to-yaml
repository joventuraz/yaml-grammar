#!/usr/bin/env perl

use strict;
use warnings;
use YAML::PP;
my $ypp = YAML::PP->new();
my $comments;

use XXX;

my $debug = 0;

sub main {
  my @files;
  for (@_) {
    if (/^--debug=(\d+)$/) {
      $debug = $1;
    }
    else {
      push @files, $_;
    }
  }

  my ($spec_html, $comment_data) = read_input_files(@files);
  $comments = $comment_data;

  my $text = reformat($spec_html);
  $text = make_yaml($text);

  for my $comment (@{$comment_data->{'000'}}) {
    print format_comment($comment);
  }

  print $text;
  print "\n# vim: iskeyword=@,+,- sw=2:\n";
}

sub read_input_files {
  my ($spec_file, $comment_file) = @_;
  open my $spec, $spec_file or
    die "Can't open '$spec_file' for input";
  my $spec_html = do { local $/; <$spec> };
  open my $comment, $comment_file or
    die "Can't open '$comment_file' for input";
  my $comment_yaml = do { local $/, <$comment> };
  my $comment_data = $ypp->load_string($comment_yaml);
  return ($spec_html, $comment_data);
}

sub format_comment {
  my ($comment) = @_;
  my $line = '#' . ('=' x 79) . "\n";
  $comment =~ s/^/# /gm;
  $comment =~ s/ +$//gm;
  return "$line$comment$line\n";
}

sub reformat {
  $_ = shift;

  # Get section containing all productions:
  s/.*
    (
      ^5\.1\.\ Character\ Set
      .*
    )
    ^\ \ \ Example\ 9\.6\.\ Stream
    .*
  /$1/smx;

  # Remove reference numbers ([123] and [1234]):
  s/\[\d{3,4}\](?!\s)//g;

  # Collapse broken comments:
  s/(\/\*[^*]+)\n/$1/g;
  s/(\/\*[^*]+)\n/$1/g;

  # Blank out text lines following a rule:
  s/^   [A-Z].*//gm;
  s/^    ? ?\* [A-Z].*//gm;

  # Remove all leading whitespace:
  s/^\ +//gm;

  # Add extra blank lines between paragraphs:
  s/^\[/\n\n[/gm;
  s/\n\n/\n\n\n/gm;

  # Remove all extra prose paragraphs:
  s/\n\n(?!\n|\[\d|\d+\.\d+\.(?:\d+\.)?\ ).*?(?=\n\n)/\n\n/gs;

  # Remove extra blank lines:
  s/\n\n+/\n\n/g;

  # Remove comments
  s/
    \ *\/\*\ +
    (?:
      (?:A|a|0|8|16|32|LF|CR|SP|TAB|DOS|MacOS|UNIX|Key|Value)
      [\-\ \,]
      .*?
    )
    \ *\*\/
  //gx;

  # Fix typo in spec:
  s/safe\(c\)\)/safe(c)/g;

  # Various normalizations:
  s/::= ([ct]) = /::=\n$1 = /g;
  s/⇒/=>/g;
  s/=>\n/=> /g;
  s/::= +/::=\n/g;
  s/ \|\n/ \| /g;
  s/ -\n/ - /g;
  s/  +/ /g;
  # s/“'”/"'"/g;
  s/“(.)”/'$1'/g;
  s/#x/x:/g;
  s/≤/<=/g;
  s/ =\n/ = /g;
  s/\)\)/) )/g;
  s/ × (\S+)/{$1}/g;

  # Make special comments into tokens:
  sub token {
    $_ = lc $_[0];
    s/\) \)/))/g;
    s/ /_/g;
    $_;
  }
  s/\/\*\ (.*?)\ \*\//'<' . token($1) . '>'/ge;

  # Parenthesize => expressions:
  s/^(.* = .*)/( $1 )/gm;

  # Remove unwanted space in a couple rules:
  s/(ns-s-flow-seq-entries\(n,in-flow\(c\)) (\)\?)/$1$2/;
  s/(ns-s-flow-map-entries\(n,in-flow\(c\)) (\)\?)/$1$2/;
  s/(l\+block-sequence\(seq-spaces\(n,c\)) (\))/$1$2/;

  # Add missing parens in rule 211:
  s/(l-document-suffix\+ l-document-prefix\*\nl-any-document\?)(\n\| )(l-document-prefix\* l-explicit-document\?)/( $1 )$2( $3 )/;


  return $_;
}

sub make_yaml {
  my $text = shift;

  my @yaml = ();

  while ($text =~ s/^(\S.*?)\n\n+//s) {
    my $para = $1;
    if ($para =~ /^\d/) {
      push @yaml, make_section_comment($para);
    }
    elsif ($debug && $para =~ /(\d+)/) {
      next unless $debug == $1;
      warn make_rule($para);
      exit;
    }
    else {
      push @yaml, make_rule($para);
    }
  }

  my $yaml = join "\n\n\n", @yaml;

  return $yaml;
}

sub make_section_comment {
  $_ = shift;

  my $comment;

  if (/^\d+\.\d+\.\d+\./) {
    return "##### $_";
  }
  else {
    return "### $_";
  }
}

my ($tokens, $num, $key);
sub make_rule {
  my $text = shift;
  my $orig = $text;

  $text =~ s/^\[(\d+)\]\ (\S+)\ ::=\n// or die $text;
  ($num, $key) = ($1, $2);

  $orig =~ s/^/  /gm;
  $orig =~ s/^  //;
  $orig =~ s/ /\n/;
  $orig =~ s/^/# /gm;
  $orig =~ s/.*\n//;

  make_tokens($text);

  my $rule;
  if ($text =~ /t = .*<end_of_file>/) {
    $rule = special_format_case_or($tokens);
  }
  elsif (ref($tokens->[0]) and (grep $_ eq '=>', @{$tokens->[0]})) {
    $rule = special_format($tokens);
  }
  elsif (@$tokens == 1 and not ref $tokens->[0]) {
    $rule = $ypp->dump($tokens->[0]);
    $rule =~ s/^--- //;
  }
  else {
    $rule = $ypp->dump($tokens);
    $rule =~ s/^---//;
  }

  $rule =~ s/- ([\w<.=+;()\/\$\\])$/- '$1'/gm;
  $rule =~ s/^(.)$/'$1'/gm;
  $rule =~ s/((?:block|flow)-(?:in|out|key)(?=[,\)]|\ \]))/"$1"/g;

  $rule =~ s/<where_m_(<=?)_n>/[ ($1), \$lastMatchLength, n]/;
  $rule =~ s/<followed_by_an_(.*)>/$1=/;
  $rule =~ s/<not_followed_by_an_(.*)>/$1!/;
  $rule =~ s/<an_ns-char_preceding>/ns-char<=/;
  $rule =~ s{<for_some_fixed_auto-detected_m_>_0>}
            {(set): [ m, <auto_detect_indent> ]};
  $rule =~ s{<excluding_c-forbidden_content>}
            {(exclude): c-forbidden};
  $rule =~ s{<at_most_1024_characters_altogether>}
            {(limit): 1024};

  $rule =~ s{n/a}{null};

  $rule =~ s/s-indent\(<n\)/s-indent-lt(n)/g;
  $rule =~ s/s-indent\(<=n\)/s-indent-le(n)/g;
  $key =~ s/s-indent\(<n\)/s-indent-lt(n)/;
  $key =~ s/s-indent\(<=n\)/s-indent-le(n)/;

  if ($rule =~ /lastMatchLength/) {
    $rule = "\n- (&)$rule";
  }

  my $yaml = "$key: $rule";
  $yaml =~ s/\ +$//gm;
  $yaml = sprintf qq{:%03d: %s\n%s\n\n%s},
    $num, $key, $orig, $yaml;

  $num = sprintf "%03d", $num;
  if (my $comment = $comments->{$num}) {
    $comment = format_comment($comment);
    $yaml = "$comment$yaml";
  }

  return $yaml;
}

sub special_format {
  my ($tokens) = @_;

  my $e = $tokens->[0];
  if (@$e == 5) {
    if ($e->[4] =~ /-.*-/) {
      return special_format_case($tokens);
    }
    if ($e->[4] =~ /(-in|-out)$/) {
      return special_format_switch($tokens);
    }
    if ($e->[2] eq 't') {
      return special_format_if_set($tokens);
    }
    if ($e->[0] eq 'c') {
      return special_format_switch_var($tokens);
    }
  }
  if (@$e == 7) {
    return special_format_if_set_number($tokens);
  }
  die;
}

sub special_format_case {
  my ($tokens) = @_;
  my $var = $tokens->[0][0];
  my $out = "\n  (case):\n    var: $var\n";
  my $l = 0;
  for my $e (@$tokens) {
    $_ = length $e->[2];
    $l = $_ if $_ > $l;
  }
  $l += 3;
  for my $e (@$tokens) {
    my ($s, $r) = @{$e}[2,4];
    $out .= sprintf "    %-${l}s %s\n", qq{"$s":}, $r;
  }
  return $out;
}

sub special_format_case_or {
  my ($tokens) = @_;
  $tokens = [ map $_->[1], @$tokens ];
  my $var = $tokens->[0][0];
  my $out = "\n  (case):\n    var: $var\n";
  my $l = 0;
  for my $e (@$tokens) {
    $_ = length $e->[2];
    $l = $_ if $_ > $l;
  }
  $l += 3;
  for my $e (@$tokens) {
    my ($s, $r) = @{$e}[2,4];
    $out .= sprintf "    %-${l}s %s\n", qq{"$s":}, qq{[ (|), $r, <end_of_file> ]};
  }
  return $out;
}

sub special_format_switch {
  my ($tokens) = @_;
  my $var = $tokens->[0][0];
  my $out = "\n  (switch):\n    var: $var\n";
  my $l = 0;
  for my $e (@$tokens) {
    $_ = length $e->[2];
    $l = $_ if $_ > $l;
  }
  $l += 3;
  for my $e (@$tokens) {
    my ($s, $r) = @{$e}[2,4];
    $out .= sprintf "    %-${l}s %s\n", qq{"$s":}, qq{"$r"};
  }
  return $out;
}

sub special_format_switch_var {
  my ($tokens) = @_;
  my $var = $tokens->[0][0];
  my $out = "\n  (switch):\n    var: $var\n";
  my $l = 0;
  for my $e (@$tokens) {
    $_ = length $e->[2];
    $l = $_ if $_ > $l;
  }
  $l += 3;
  for my $e (@$tokens) {
    my ($s, $v) = @{$e}[2,4];
    if ($v eq 'n-1') {
      $v = "[ (minus-1), n ]";
    }
    $out .= sprintf "    %-${l}s %s\n", qq{"$s":}, $v;
  }
  return $out;
}

sub special_format_if_set {
  my ($tokens) = @_;
  my $out = "\n- (|)\n";
  for my $e (@$tokens) {
    my ($rule, $var, $val) = @{$e}[0, 2,4];
    $rule = "'$rule'" if length $rule == 1;
    $out .= qq{- (if):  $rule\n};
    $out .= qq{  (set): [ $var, "$val" ]\n};
  }
  return $out;
}

sub special_format_if_set_number {
  my ($tokens) = @_;
  my $out = "\n- (|)\n";
  for my $e (@$tokens) {
    my ($rule, $var, $val) = @{$e}[0, 2,4];
    if ($val eq 'ns-dec-digit') {
      $val = '[ (charToInt), $lastMatch ]';
    } elsif ($val eq 'auto-detect()') {
      $val = '"auto-detect"';
    } else { die }
    $out .= qq{- (if):  $rule\n};
    $out .= qq{  (set): [ $var, $val ]\n};
  }
  return $out;
}

sub make_tokens {
  my $text = shift;
  $tokens = [];
  my $insert = [$tokens];
  my @input = split /\s+/, $text;

  if (@input > 1 and $input[0] =~ /^'([?*|])'$/) {
    $input[0] = "$1";
  }

  for (my $i = 0; $i < @input; $i++) {
    my $token = $input[$i];

    if ($token eq '|' and
        @{$insert->[-1]} > 1 and
        not grep $_ eq '|', @{$insert->[-1]}
    ) {
      my $array = $insert->[-1];
      @$array = ([@$array], '|');
      next;
    }
    if ($token eq '(') {
      my $array = [];

      push @{$insert->[-1]}, $array;
      push @$insert, $array;
      next;
    }
    elsif ($token =~ /^\)([\*\+\?]?)/) {
      my $q = $1 || '';
      my $array = pop @$insert;
      if (@$array > 1 and $array->[1] =~ /^[-|]$/) {
        my $operator = $array->[1];
        @$array = grep { $_ ne $operator } @$array;
        unshift @$array, "($operator)";
        if ($q) {
          my @array;
          while (@$array) {
            push @array, shift(@$array);
          }
          push @$array, "($q)", \@array;
        }
      }
      elsif ($q) {
        unshift @$array, "($q)";
      }
      next;
    }
    push @{$insert->[-1]}, format_token($token);
  }
  if (@$tokens > 1 and $tokens->[1] =~ /^[-|]$/ and $tokens->[0] ne $tokens->[1]) {
    my $operator = $tokens->[1];
    my $i = 0;
    @$tokens = grep { ++$i % 2 } @$tokens;
    unshift @$tokens, "($operator)";
  }

  for (my $i = 0; $i < @$tokens; $i++) {
    my $token = $tokens->[$i];
    if (ref($token) eq 'ARRAY' and @$token == 1) {
      $tokens->[$i] = $token->[0];
    }
  }

  if (
    ref($tokens) eq 'ARRAY' and
    @$tokens == 1 and
    ref($tokens->[0]) eq 'ARRAY'
  ) {
    $tokens = $tokens->[0];
  }

  if (
    ref($tokens) eq 'ARRAY' and
    @$tokens >= 2
  ) {
    if ($tokens->[1] eq '<for_some_fixed_auto-detected_m_>_0>') {
      my $token = $tokens->[1];
      $tokens = $tokens->[0];
      splice(@$tokens, 1, 0, $token);
    }
    elsif (
      $tokens->[-1] eq '<excluding_c-forbidden_content>' or
      $tokens->[-1] eq '<at_most_1024_characters_altogether>'
    ) {
      unshift @$tokens, pop @$tokens;
    }
  }

  # warn $ypp->dump(["($num) $key", $text, $tokens]) if $num >= 1;
}

sub format_token {
  $_ = shift;

  if (/^x:(.*)/) {
    $_ = format_hex($1);
  }
  elsif (/^\[x:(.*)-x:(.*)\]$/) {
    $_ = format_hex($1) . '-' . format_hex($2);
  }
  elsif (/^'(.*)'/) {
    $_ = $1;
  }
  elsif (s/\{m\}$/*/) {
  }

  $_;
}

sub format_hex {
  $_ = shift;
  if (length("$_") % 2) {
    $_ = "0$_"
  }
  return "x$_";
}

main @ARGV;

# vim: sw=2:
