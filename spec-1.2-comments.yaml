---
'000':
- |
  This YAML grammar was generated from https://yaml.org/spec/1.2/spec.html by:
  https://github.com/yaml/yaml-grammar/tree/master/bin/yaml-grammar-html-to-yaml

  This grammar is a YAML file that should be loadable by any decent existing
  YAML loader. It can easily converted to JSON. In fact, the JSON is already
  generated next to this file in the repository.

  Its purpose is to:
  * Make the spec clearer and more precise to people implementing YAML parsers
  * To generate 100% correct parsers in most programming languages

  This grammar mirrors the 1.2 spec faithfully, but tries to express the rules
  in a more concrete and programatic fashion. Some of the rules that are more
  difficult to explain have comment sections (like this one) to explain things.
  Each rule is prefixed by the original YAML 1.2 spec rule text, formatted as a
  comment.
- |2+

    = Syntax Guide =

  The following is an explanation of the various EBNF/DSL syntax forms used in
  this grammar.

  There are 211 rules in the YAML 1.2 spec. This grammar file has 211 sections,
  one for each rule. The overall structure of this file is a big mapping with
  2 pairs for each grammar rule. Each rule group looks like this:

    rule-number -> rule-name
    <original spec rule as a comment>
    rule-name   -> rule definition

  The first pair is just for indexing the rule back to the 1.2 spec. The rule
  definition is the important part. Complex definitions are data structures
  mostly comprised of other rule-names. The simplest rules point to single
  characters. This forms a top-down grammar where the top is the last rule,
  #211.


    == Rule Names ==

  A rule name consists of groups of lower case characters and numbers separated
  by dashes (`-`).

  Some rule names also have trailing arguments of the form `(x)` or `(x,y)`.
  These arguments are considered a literal part of the name in the grammar
  form.

  Each rule name has a 1 or 2 character prefix indicating the rule type.

  Example rule names:

    * nb-foo-bar
    * nb+foo-bar
    * nb-foo-bar(n)
    * nb-foo-bar(n,c)


    === Rule Name Prefixes ===

  The rule type prefixes are:

    e  -- Empty (matches no characters)
    c  -- Character (match one single character)
    b  -- Break (match a single line break character)
    nb -- Non-break (match a single non-break character)
    s  -- Space (match a single whitespace character)
    ns -- Non-space (match a single non-space character)
    l  -- Line (match a complete line)

  And also (where X and Y are each one of the above prefixes):

    X-Y  -- Match starting with an X- character and ending with a Y- character
    X+   -- Match X where indentation is greater than n
    X-Y+ -- Match X-Y where indentation is greater than n


    === Rules Variables ===

  Some rules are defined with trailing arguments indicating that they should be
  passed values when being used. There are 3 distinct variables used in the
  YAML 1.2 grammar.

    n -- Current indentation level. An integer indicating the number of spaces.

    c -- Current context. String that is one of:
      * "block-in"
      * "block-out"
      * "block-key"
      * "flow-in"
      * "flow-out"
      * "flow-key"

    t -- How to treat whitespace after a literal scalar. One of:
      * "strip"
      * "clip"
      * "keep"

  The starting values of n (-1) and c ("block-in") are set in rule #207.


    == Rule Definitions ==

  The rule definitions here are expressed as YAML data structures where the
  scalar values can be:

    * A rule name
    * A literal character (always single quoted for clarity)
    * Some special DSL forms

  The various DSL forms were chosen carefully to be easily read and understood
  by the people reading it. The rest of this section describes those forms.


    === Groups ===

  Each sequence is a group (things that are parenthesized). An element of a
  group may be another group.

  If the first element of the sequence is the string `(|)`, then ONE of the
  remaining elements must match for that group to match. This is used to
  express rules of the form `( a | b | c )`.

  Otherwise ALL of the remaining elements must match. ie `( a b c )`.

  If the first element of a group is `(*)`, `(+)` or `(?)`:

    * (*) The entire group must match 0 or more times
    * (+) The entire group must match 1 or more times
    * (?) The entire group must match 0 or 1 times

  If the first element of a group is `(-)`, then the following elements all
  represent sets of characters. The overall meaning is a set of characters
  consisting of the first set minus all the following sets.


    === Hex Codes ===

  Hex codes are scalars beginning with `x:` followed by an even number of
  hexadecimal digits.

  There are hex ranges as well, which consist of 2 hex codes separated by a
  dash.


    === Rule Quantifiers ===

  Rule names can end with a quantifier indicating how many times they should
  match.

    * `+`    -- 1 or more times
    * `*`    -- 0 or more times
    * `?`    -- 0 or 1 times
    * `{n}`  -- n times

    === Rule Assertions ===

  Rule names can end with an assertion indicator. This means they must match
  but do not consume any text in the parsing process.

    * `=`    -- Positive look-ahead assertion
    * `!`    -- Negative look-ahead assertion

'003': |
  Rules 003-021 define single characters. These rules are never referenced in
  the rest of the grammar. They should at least be referenced in rule 022.
'022': |
  Rule 022 should probably be defined using the rule names above rather than
  literal characters.
'067': |
  A `(case)` statement is a mapping that chooses the next rule based on the
  value of a state variable (in this case `c`).

  7 rules in this grammar have case statements.
'183': |
  XXX Need figure out what <for_some_fixed_auto-detected_m_>_0> is about
